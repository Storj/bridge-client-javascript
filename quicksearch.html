<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"lib_client.js.html":{"id":"lib_client.js.html","title":"Source: lib/client.js","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Source: lib/client.js 'use strict'; var fs = require('fs'); var async = require('async'); var crypto = require('crypto'); var assert = require('assert'); var querystring = require('querystring'); var request = require('request'); var ms = require('ms'); var EventEmitter = require('events').EventEmitter; var ReadableStream = require('readable-stream'); var KeyPair = require('./keypair'); /** * Exposes a MetaDisk API client * @constructor * @param {String} uri - API base URI ('https://api.metadisk.org') * @param {Object} options * @param {KeyPair} options.keypair - KeyPair instance for request signing * @param {Object} options.basicauth * @param {String} options.basicauth.email - Email address for HTTP basic auth * @param {String} options.basicauth.password - Password for HTTP basic auth */ function Client(uri, options) { if (!(this instanceof Client)) { return new Client(uri, options); } assert.ok(options, 'Invalid options supplied'); this._options = options; this._options.baseURI = uri || 'https://api.metadisk.org'; } /** * Get the remote MetaDisk API documentation and version as JSON * @returns {Promise} */ Client.prototype.getInfo = function() { return this._request('GET', '/', {}); }; /** * Registers a user account * @param {String} email - Email address for verification email * @param {String} password - Password to register (hashed automatically) * @returns {Promise} */ Client.prototype.createUser = function(email, password) { return this._request('POST', '/users', { email: email, password: this._sha256(password) }); }; /** * Returns list of associated public keys * @returns {Promise} */ Client.prototype.getPublicKeys = function() { return this._request('GET', '/keys', {}); }; /** * Registers a public key for the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @returns {Promise} */ Client.prototype.addPublicKey = function(pubkey) { return this._request('POST', '/keys', { key: pubkey }); }; /** * Disassociates the public key from the caller * @param {String} pubkey - Hex encoded ECDSA (secp256k1) public key * @returns {Promise} */ Client.prototype.destroyPublicKey = function(pubkey) { return this._request('DELETE', '/keys/' + pubkey, {}); }; /** * Lists the caller's file buckets * @returns {Promise} */ Client.prototype.getBuckets = function() { return this._request('GET', '/buckets', {}); }; /** * Returns the bucket information by ID * @param {String} id - Unique bucket ID * @returns {Promise} */ Client.prototype.getBucketById = function(id) { return this._request('GET', '/buckets/' + id, {}); }; /** * Creates a new file bucket * @param {Object} data - Bucket parameters for creation * @returns {Promise} */ Client.prototype.createBucket = function(data) { return this._request('POST', '/buckets', data || {}); }; /** * Removes the bucket * @param {String} id - Unique bucket ID * @returns {Promise} */ Client.prototype.destroyBucketById = function(id) { return this._request('DELETE', '/buckets/' + id, {}); }; /** * Updates the bucket * @param {String} id - Unique bucket ID * @param {Object} updates - Bucket update parameters * @returns {Promise} */ Client.prototype.updateBucketById = function(id, updates) { return this._request('PATCH', '/buckets/' + id, updates || {}); }; /** * Lists the files stored in a bucket * @param {String} id - Unique bucket ID * @returns {Promise} */ Client.prototype.listFilesInBucket = function(id) { return this._request('GET', '/buckets/' + id + '/files', {}); }; /** * Create bucket token * @param {String} id - Unique bucket ID * @param {String} operation - PUSH or PULL (file operation) * @returns {Promise} */ Client.prototype.createToken = function(id, operation) { return this._request('POST', '/buckets/' + id + '/tokens', { operation: operation }); }; /** * Stores a file in the bucket * @param {String} id - Unique bucket ID * @param {String} token - Token from {@link Client#createToken} * @param {String|Buffer} file - Raw binary buffer or path to local file * @returns {Promise} */ Client.prototype.storeFileInBucket = function(id, token, file) { var self = this; var size = 0; assert( typeof window === 'undefined', 'This method is not supported in the browser' ); if (!Buffer.isBuffer(file)) { size = fs.statSync(file).size; } else { size = file.length; } return new Promise(function(resolve, reject) { request({ method: 'PUT', baseUrl: self._options.baseURI, uri: '/buckets/' + id + '/files', json: true, timeout: ms('10m'), forever: true, headers: { 'x-token': token, 'x-filesize': size }, formData: { data: Buffer.isBuffer(file) ? file : fs.createReadStream(file) } }, function(err, res, body) { if (err) { return reject(err); } if (res.statusCode !== 200 &amp;&amp; res.statusCode !== 304) { return reject(new Error(body.error || body)); } resolve(body); }); }); }; /** * Retrieves a file pointer from the bucket * @param {String} bucket - Unique bucket ID * @param {String} token - Token from {@link Client#createToken} * @param {String} fileHash - The unique file pointer ID * @returns {Promise} */ Client.prototype.getFilePointer = function(bucket, token, fileHash) { var self = this; return new Promise(function(resolve, reject) { request({ method: 'GET', baseUrl: self._options.baseURI, uri: '/buckets/' + bucket + '/files/' + fileHash, headers: { 'x-token': token }, json: true, timeout: ms('10m'), }, function(err, res, body) { if (err) { return reject(err); } if (res.statusCode !== 200 &amp;&amp; res.statusCode !== 304) { return reject(new Error(body.error || body)); } resolve(body); }); }); }; /** * Dispatches a series of requests based on the returned value of * {@link Client#getFilePointer} to resolve all the shards and * reassemble them together * @param {Array} pointers - Result of {@link Client#getFilePointer} * @returns {ReadableStream} */ Client.prototype.resolveFileFromPointers = function(pointers) { var self; function resolveFile(limit, callback) { var emitter = new EventEmitter(); async.mapLimit(pointers, limit, function(pointer, done) { var contact = pointer.destination; request({ uri: 'http://' + contact.address + ':' + contact.port, method: 'POST', body: JSON.stringify(pointer.payload) }, function(err, res, body) { var shard; if (err) { return done(err); } try { shard = new Buffer(JSON.parse(body).result.data_shard, 'hex'); } catch (err) { return done(err); } emitter.emit('data', shard); done(null); }); }, function onAllShardsResolved(err) { if (err) { return emitter.emit('error', err); } emitter.emit('end'); }); return emitter; } return new ReadableStream({ read: function() { var self = this; if (this._isResolving) { return; } this._isResolving = true; resolveFile(1).on('data', function(chunk) { self.push(chunk); }).on('end', function() { self.push(null); }); } }); }; /** * Returns the SHA-256 hash of the given input data * @private * @param {String} data * @returns {String} */ Client.prototype._sha256 = function(data) { return crypto.createHash('sha256').update(data).digest('hex'); }; /** * Sends a request to the metadisk-api * @private * @param {String} method - HTTP verb * @param {String} path - Endpoint path * @param {Object} params - Request parameters * @param {Boolean} stream - Return the raw response stream? * @returns {Promise} */ Client.prototype._request = function(method, path, params, stream) { var opts = { baseUrl: this._options.baseURI, uri: path, method: method }; params.__nonce = Date.now(); if (['GET', 'DELETE'].indexOf(method) !== -1) { opts.qs = params; opts.json = true; } else { opts.json = params; } this._authenticate(opts); if (stream) { return request(opts); } return new Promise(function(resolve, reject) { request(opts, function(err, res, body) { if (err) { return reject(err); } if (res.statusCode !== 200 &amp;&amp; res.statusCode !== 304) { return reject(new Error(body.error || body)); } resolve(body); }); }); }; /** * Adds authentication headers to request object * @private * @param {Object} opts - Options parameter passed to request * @return {Object} */ Client.prototype._authenticate = function(opts) { if (this._options.keypair) { var payload = ['GET', 'DELETE'].indexOf(opts.method) !== -1 ? querystring.stringify(opts.qs) : JSON.stringify(opts.json); var keypair = KeyPair(this._options.privkey); var contract = [opts.method, opts.uri, payload].join('\\n'); opts.headers = opts.headers || {}; opts.headers['x-pubkey'] = this._options.keypair.getPublicKey(); opts.headers['x-signature'] = this._options.keypair.sign(contract); } else if (this._options.basicauth) { opts.auth = { user: this._options.basicauth.email, pass: this._sha256(this._options.basicauth.password) }; } return opts; }; module.exports = Client; × Search results Close "},"index.js.html":{"id":"index.js.html","title":"Source: index.js","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Source: index.js /** * @module metadisk-client */ 'use strict'; /** {@link Client} */ module.exports.Client = require('./lib/client'); /** {@link KeyPair} */ module.exports.KeyPair = require('./lib/keypair'); × Search results Close "},"lib_keypair.js.html":{"id":"lib_keypair.js.html","title":"Source: lib/keypair.js","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Source: lib/keypair.js 'use strict'; var assert = require('assert'); var crypto = require('crypto'); var elliptic = require('elliptic'); var ecdsa = new elliptic.ec(elliptic.curves.secp256k1); /** * Creates a ECDSA key pair instance * @constructor * @param {String|Buffer} privkey - Hex encoded ECDSA (secp256k1) public key */ function KeyPair(privkey) { if (!(this instanceof KeyPair)) { return new KeyPair(privkey); } if (privkey) { this._keypair = ecdsa.keyFromPrivate(privkey); } else { this._keypair = ecdsa.genKeyPair(); } } /** * Returns the private key * @returns {String} */ KeyPair.prototype.getPrivateKey = function() { return this._keypair.getPrivate().toString('hex'); }; /** * Returns the public key * @returns {String} */ KeyPair.prototype.getPublicKey = function() { var pubkey, pubkeyobj = this._keypair.getPublic(); var xbuf = new Buffer(pubkeyobj.x.toString('hex', 64), 'hex'); var ybuf = new Buffer(pubkeyobj.y.toString('hex', 64), 'hex'); if (ybuf[ybuf.length - 1] % 2) { pubkey = Buffer.concat([new Buffer([3]), xbuf]); } else { pubkey = Buffer.concat([new Buffer([2]), xbuf]); } return pubkey.toString('hex'); }; /** * Returns the nodeID * @returns {String} */ KeyPair.prototype.getNodeID = function() { function getNodeIdFromPublicKey(pubkey) { if (!Buffer.isBuffer(pubkey)) { pubkey = new Buffer(pubkey, 'hex'); } var pubhash = crypto.createHash('sha256').update(pubkey).digest(); var pubripe = crypto.createHash('rmd160').update(pubhash).digest(); return pubripe.toString('hex'); } return getNodeIdFromPublicKey(this.getPublicKey()); }; /** * Sign a message * @param {String|Buffer} data - Message to sign * @returns {String} */ KeyPair.prototype.sign = function(data) { if (!Buffer.isBuffer(data)) { data = new Buffer(data, 'utf8'); } return ecdsa.sign( crypto.createHash('sha256').update(data).digest('hex'), this.getPrivateKey() ).toDER('hex'); }; /** * Verify a signature * @param {String|Buffer} data - Message to verify * @param {String|Buffer} pubkey - Hex encoded ECDSA (secp256k1) public key * @param {String|Buffer} signature - DER signature (hex) * @returns {Boolean} */ KeyPair.prototype.verify = function(data, pubkey, signature) { if (!Buffer.isBuffer(data)) { data = new Buffer(data, 'utf8'); } if (!Buffer.isBuffer(signature)) { signature = new Buffer(signature, 'hex'); } if (!Buffer.isBuffer(pubkey)) { pubkey = new Buffer(pubkey, 'hex'); } return ecdsa.verify( crypto.createHash('sha256').update(data).digest('hex'), signature, pubkey ); }; module.exports = KeyPair; × Search results Close "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Modules Classes Client KeyPair × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Classes Classes Client KeyPair × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair MetaDisk ClientA Simple HTTP client for communicating with the MetaDisk API. Quick StartInstall the MetaDisk client tools using NPM: npm install metadisk-client --saveOptionally build a browser bundle: npm run buildExamplesRegister a user account on MetaDisk: // Import the client var metadisk = require('metadisk-client'); // Create unauthenticated instance var client = new metadisk.Client('https://api.metadisk.org'); // Register a user account client.createUser('you@domain.tld', 'somebigsecret').then(function(result) { console.log(result); }, function(err) { console.log(err); });Create a storage bucket for your user: // Import the client var metadisk = require('metadisk-client'); // Authenticate with credentials var client = new metadisk.Client('https://api.metadisk.org', { basicauth: { email: 'you@domain.tld', password: 'somebigsecret' } }); // Create a bucket and print the result client.createBucket().then(function(result) { console.log(result); }, function(err) { console.log(err); });Store and retrieve a file from the Storj network: var fs = require('fs'); // Import the library var metadisk = require('metadisk-client'); // Create a client authenticated with your key var client = new metadisk.Client('https://api.metadisk.org', { keypair: new metadisk.KeyPair('&lt;your_private_ecdsa_key&gt;') }); // Keep track of the bucket ID and file hash var bucket = '56d6048ab3dece1959aace73'; var filehash = null; // Create a PUSH token client.createToken(bucket, 'PUSH').then(function(token) { // Stream the file upload to metadisk return client.storeFileInBucket(bucket, token.token, process.argv[2]); }).then(function(filepointer) { // Track the file hash for later filehash = filepointer.hash; // Create a PULL token return client.createToken(bucket, 'PULL'); }).then(function(token) { // Fetch the file pointer list return client.getFilePointer(bucket, token.token, filehash); }).then(function(pointers) { // Open download stream from network and a writable file stream var download = client.resolveFileFromPointers(pointers); var destination = fs.createWriteStream('&lt;write_file_to_path&gt;'); // Write downloaded file to disk download.pipe(destination); });LicenseMetaDisk Client - Copyright (C) 2016 Storj Labs, Inc This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details. You should have received a copy of the GNU Lesser General Public License along with this program. If not, see http://www.gnu.org/licenses/. × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Class: Client Client new Client(uri, options) Exposes a MetaDisk API client Parameters: Name Type Description uri String API base URI ('https://api.metadisk.org') options Object Properties Name Type Description keypair KeyPair KeyPair instance for request signing basicauth Object Properties Name Type Description email String Email address for HTTP basic auth password String Password for HTTP basic auth Source: lib/client.js, line 24 Methods updateBucketById(id, updates) Updates the bucket Parameters: Name Type Description id String Unique bucket ID updates Object Bucket update parameters Source: lib/client.js, line 123 Returns: Type Promise getInfo() Get the remote MetaDisk API documentation and version as JSON Source: lib/client.js, line 39 Returns: Type Promise createUser(email, password) Registers a user account Parameters: Name Type Description email String Email address for verification email password String Password to register (hashed automatically) Source: lib/client.js, line 49 Returns: Type Promise getPublicKeys() Returns list of associated public keys Source: lib/client.js, line 60 Returns: Type Promise addPublicKey(pubkey) Registers a public key for the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key Source: lib/client.js, line 69 Returns: Type Promise destroyPublicKey(pubkey) Disassociates the public key from the caller Parameters: Name Type Description pubkey String Hex encoded ECDSA (secp256k1) public key Source: lib/client.js, line 78 Returns: Type Promise getBuckets() Lists the caller's file buckets Source: lib/client.js, line 86 Returns: Type Promise getBucketById(id) Returns the bucket information by ID Parameters: Name Type Description id String Unique bucket ID Source: lib/client.js, line 95 Returns: Type Promise createBucket(data) Creates a new file bucket Parameters: Name Type Description data Object Bucket parameters for creation Source: lib/client.js, line 104 Returns: Type Promise destroyBucketById(id) Removes the bucket Parameters: Name Type Description id String Unique bucket ID Source: lib/client.js, line 113 Returns: Type Promise listFilesInBucket(id) Lists the files stored in a bucket Parameters: Name Type Description id String Unique bucket ID Source: lib/client.js, line 132 Returns: Type Promise createToken(id, operation) Create bucket token Parameters: Name Type Description id String Unique bucket ID operation String PUSH or PULL (file operation) Source: lib/client.js, line 142 Returns: Type Promise storeFileInBucket(id, token, file) Stores a file in the bucket Parameters: Name Type Description id String Unique bucket ID token String Token from Client#createToken file String | Buffer Raw binary buffer or path to local file Source: lib/client.js, line 155 Returns: Type Promise getFilePointer(bucket, token, fileHash) Retrieves a file pointer from the bucket Parameters: Name Type Description bucket String Unique bucket ID token String Token from Client#createToken fileHash String The unique file pointer ID Source: lib/client.js, line 206 Returns: Type Promise resolveFileFromPointers(pointers) Dispatches a series of requests based on the returned value of Client#getFilePointer to resolve all the shards and reassemble them together Parameters: Name Type Description pointers Array Result of Client#getFilePointer Source: lib/client.js, line 240 Returns: Type ReadableStream × Search results Close "},"module-metadisk-client.html":{"id":"module-metadisk-client.html","title":"Module: metadisk-client","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Module: metadisk-client Source: index.js, line 1 Members &lt;static&gt; KeyPair KeyPair Source: index.js, line 10 &lt;static&gt; Client Client Source: index.js, line 8 × Search results Close "},"KeyPair.html":{"id":"KeyPair.html","title":"Class: KeyPair","body":" MetaDisk Client Modules metadisk-client Classes ClientKeyPair Class: KeyPair KeyPair new KeyPair(privkey) Creates a ECDSA key pair instance Parameters: Name Type Description privkey String | Buffer Hex encoded ECDSA (secp256k1) public key Source: lib/keypair.js, line 13 Methods getPrivateKey() Returns the private key Source: lib/keypair.js, line 29 Returns: Type String getPublicKey() Returns the public key Source: lib/keypair.js, line 37 Returns: Type String getNodeID() Returns the nodeID Source: lib/keypair.js, line 55 Returns: Type String sign(data) Sign a message Parameters: Name Type Description data String | Buffer Message to sign Source: lib/keypair.js, line 75 Returns: Type String verify(data, pubkey, signature) Verify a signature Parameters: Name Type Description data String | Buffer Message to verify pubkey String | Buffer Hex encoded ECDSA (secp256k1) public key signature String | Buffer DER signature (hex) Source: lib/keypair.js, line 93 Returns: Type Boolean × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
